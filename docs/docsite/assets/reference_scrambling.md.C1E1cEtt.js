import{_ as t,c as i,o as a,ae as s}from"./chunks/framework.C5RTWoTo.js";const g=JSON.parse('{"title":"Point Light Display","description":"","frontmatter":{"layout":"doc","title":"Point Light Display","prev":{"text":"Point-Light Display","link":"/reference/pld"},"next":{"text":"Temporal Transforms","link":"/reference/temporal_transforms"}},"headers":[],"relativePath":"reference/scrambling.md","filePath":"reference/scrambling.md"}'),l={name:"reference/scrambling.md"};function n(d,e,r,o,h,c){return a(),i("div",null,e[0]||(e[0]=[s(`<h1 id="scrambling-module-reference" tabindex="-1">Scrambling Module Reference <a class="header-anchor" href="#scrambling-module-reference" aria-label="Permalink to &quot;Scrambling Module Reference&quot;">​</a></h1><h2 id="facial_scramble" tabindex="-1">Facial Scrambling <a class="header-anchor" href="#facial_scramble" aria-label="Permalink to &quot;Facial Scrambling {#facial_scramble}&quot;">​</a></h2><p>The <code>facial_scramble()</code> function is essentially two functions disguised as one, providing users the ability to perform grid-based and landmark-based shuffling of the face. The input parameter <code>scramble_method</code> defines the type of facial scrambling to be performed, which can be <code>pyfame.HIGH_LEVEL_GRID_SCRAMBLE</code>, <code>pyfame.LOW_LEVEL_GRID_SCRAMBLE</code> or <code>pyfame.LANDMARK_SCRAMBLE</code>. High level grid scramble will reshuffle the facial grid squares purely randomly, while low level grid scramble will reshuffle the facial grid squares within their rows, with the bounds of their random positional reassignment determined by parameter <code>grid_scramble_threshold</code>. Landmark-based scrambling will cut out and store the eyes, eyebrows, nose, and mouth, and randomly reorient and reposition them over the face. As all of the scrambling methods heavily rely on random number generation, the random number generator can be seeded with parameter <code>rand_seed</code> to ensure reproducible results.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> facial_scramble</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    input_dir:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, output_dir:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, out_grayscale:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> False</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, scramble_method:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> HIGH_LEVEL_GRID_SCRAMBLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rand_seed:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, grid_scramble_threshold:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, grid_square_size:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 40</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    with_sub_dirs:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> False</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_detection_confidence:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">float</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, min_tracking_confidence:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">float</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span></code></pre></div><table tabindex="0"><thead><tr><th style="text-align:left;">Parameter</th><th style="text-align:left;">Type</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;"><code>input_dir</code></td><td style="text-align:left;"><code>str</code></td><td style="text-align:left;">A path string to the directory containing files to process.</td></tr><tr><td style="text-align:left;"><code>output_dir</code></td><td style="text-align:left;"><code>str</code></td><td style="text-align:left;">A path string to the directory where processed files will be output.</td></tr><tr><td style="text-align:left;"><code>out_grayscale</code></td><td style="text-align:left;"><code>bool</code></td><td style="text-align:left;">A boolean flag indicating if the output image or video should be written in grayscale.</td></tr><tr><td style="text-align:left;"><code>scramble_method</code></td><td style="text-align:left;"><code>int</code></td><td style="text-align:left;">An integer flag specifying the facial scrambling method. One of <code>pyfame.HIGH_LEVEL_GRID_SCRAMBLE</code>, <code>pyfame.LOW_LEVEL_GRID_SCRAMBLE</code> or <code>pyfame.LANDMARK_SCRAMBLE</code></td></tr><tr><td style="text-align:left;"><code>rand_seed</code></td><td style="text-align:left;"><code>int</code></td><td style="text-align:left;">A seed to be passed to the random number generator, to ensure reproduceable results.</td></tr><tr><td style="text-align:left;"><code>grid_scramble_threshold</code></td><td style="text-align:left;"><code>int</code></td><td style="text-align:left;">An integer specifying the max horizontal distance an individual grid square can be randomly moved when performing a low-level grid scramble.</td></tr><tr><td style="text-align:left;"><code>grid_square_size</code></td><td style="text-align:left;"><code>int</code></td><td style="text-align:left;">An integer specifying the square dimensions of each individual grid square that makes up the overlayed facial grid. The default value of 40 defines (40px, 40px) grid squares.</td></tr><tr><td style="text-align:left;"><code>with_sub_dirs</code></td><td style="text-align:left;"><code>bool</code></td><td style="text-align:left;">A boolean flag indicating if the input directory contains sub-directories.</td></tr><tr><td style="text-align:left;"><code>min_detection_confidence</code></td><td style="text-align:left;"><code>float</code></td><td style="text-align:left;">A confidence measure in the range [0,1], passed on to the MediaPipe FaceMesh model.</td></tr><tr><td style="text-align:left;"><code>min_tracking_confidence</code></td><td style="text-align:left;"><code>float</code></td><td style="text-align:left;">A confidence measure in the range [0,1], passed on to the MediaPipe FaceMesh model.</td></tr></tbody></table><h3 id="scramble_error" tabindex="-1">Error Handling <a class="header-anchor" href="#scramble_error" aria-label="Permalink to &quot;Error Handling {#scramble_error}&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">Raises</th><th style="text-align:left;">Encountered Error</th></tr></thead><tbody><tr><td style="text-align:left;"><code>ValueError</code></td><td style="text-align:left;">Given unrecognized input parameter values.</td></tr><tr><td style="text-align:left;"><code>TypeError</code></td><td style="text-align:left;">Given invalid input parameter typings.</td></tr><tr><td style="text-align:left;"><code>OSError</code></td><td style="text-align:left;">Given an invalid path-string for either <code>input_dir</code> or <code>output_dir</code>.</td></tr><tr><td style="text-align:left;"><code>FileReadError</code></td><td style="text-align:left;">If an error is encountered instantiating <code>cv2.VideoCapture()</code> or calling <code>cv2.imRead()</code>.</td></tr><tr><td style="text-align:left;"><code>FileWriteError</code></td><td style="text-align:left;">If an error is encountered instantiating <code>cv2.VideoWriter()</code> or calling <code>cv2.imWrite()</code>.</td></tr><tr><td style="text-align:left;"><code>UnrecognizedExtensionError</code></td><td style="text-align:left;">If the function encounters an unrecognized image or video file extension.</td></tr><tr><td style="text-align:left;"><code>FaceNotFoundError</code></td><td style="text-align:left;">If the mediapipe FaceMesh model cannot identify a face in the input image or video.</td></tr></tbody></table>`,7)]))}const k=t(l,[["render",n]]);export{g as __pageData,k as default};
