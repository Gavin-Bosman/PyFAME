import{_ as e,c as i,o as a,ae as s}from"./chunks/framework.C5RTWoTo.js";const g=JSON.parse('{"title":"Utilities","description":"","frontmatter":{"layout":"doc","title":"Utilities","prev":{"text":"Temporal Transforms","link":"/reference/temporal_transforms"},"next":false},"headers":[],"relativePath":"reference/utils.md","filePath":"reference/utils.md"}'),l={name:"reference/utils.md"};function n(d,t,o,r,h,p){return a(),i("div",null,t[0]||(t[0]=[s('<h1 id="utilities-module-reference" tabindex="-1">Utilities Module Reference <a class="header-anchor" href="#utilities-module-reference" aria-label="Permalink to &quot;Utilities Module Reference&quot;">​</a></h1><h2 id="retrieving-variable-names-from-memory" tabindex="-1">Retrieving Variable Names From Memory <a class="header-anchor" href="#retrieving-variable-names-from-memory" aria-label="Permalink to &quot;Retrieving Variable Names From Memory&quot;">​</a></h2><p>The function <code>get_variable_name()</code> is frequently used within the package&#39;s internal logging calls. <code>get_variable_name()</code> takes in a variable of any type, and a namespace/scope (one of <code>locals()</code> or <code>globals()</code>), then returns the variables name in the given namespace as a string.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_variable_name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(variable, namespace) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span></code></pre></div><table tabindex="0"><thead><tr><th style="text-align:left;">Parameter</th><th style="text-align:left;">Type</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;"><code>variable</code></td><td style="text-align:left;"><code>any</code></td><td style="text-align:left;">A variable defined in the namespace provided.</td></tr><tr><td style="text-align:left;"><code>namespace</code></td><td style="text-align:left;"><code>callable</code></td><td style="text-align:left;">The namespace the variable occupies, one of <code>locals()</code> or <code>globals()</code>.</td></tr></tbody></table><h2 id="compute-the-angular-displacement-between-two-slopes" tabindex="-1">Compute The Angular Displacement Between Two Slopes <a class="header-anchor" href="#compute-the-angular-displacement-between-two-slopes" aria-label="Permalink to &quot;Compute The Angular Displacement Between Two Slopes&quot;">​</a></h2><p>Utilized in many of the facial manipulations to aid in positional tracking, <code>calculate_rot_angle()</code> takes in two slopes, and returns the angular displacement in radians between the two slopes. The second slope parameter defaults to 0.0, which allows you to retreive the angular displacement from the x-axis.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compute_rot_angle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(slope1:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, slope2:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">float</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0.0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">float</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span></code></pre></div><table tabindex="0"><thead><tr><th style="text-align:left;">Parameter</th><th style="text-align:left;">Type</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;"><code>slope1</code></td><td style="text-align:left;"><code>float</code></td><td style="text-align:left;">The current slope value.</td></tr><tr><td style="text-align:left;"><code>slope2</code></td><td style="text-align:left;"><code>float</code></td><td style="text-align:left;">The previous slope value, or the x-axis if there is no previous slope.</td></tr></tbody></table><h2 id="calculate-the-intersection-point-of-two-lines" tabindex="-1">Calculate The Intersection Point of Two Lines <a class="header-anchor" href="#calculate-the-intersection-point-of-two-lines" aria-label="Permalink to &quot;Calculate The Intersection Point of Two Lines&quot;">​</a></h2><p>Another utility function frequently used internally by the facial manipulation functions, in order to aid in positional tracking. <code>compute_line_intersection()</code> takes in two (x,y) pixel coordinates, and a line defined by an integer. If the path connecting the two points intersects with the provided line, the intersection point will be returned as a tuple containing the (x,y) pixel coordinates of the intersection. If no intersection point is found, <code>None</code> will be returned. The comparison line must be paralell to one of the axes; input parameter <code>vertical</code> is a boolean flag specifying the comparison case where the line is paralell to the y-axis, where it is paralell to the x-axis by default.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> compute_line_intersection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(p1:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, p2:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, line:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, vertical:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">False</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tuple</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span></code></pre></div><table tabindex="0"><thead><tr><th style="text-align:left;">Parameter</th><th style="text-align:left;">Type</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;"><code>p1</code></td><td style="text-align:left;"><code>tuple[int]</code></td><td style="text-align:left;">The (x,y) integer coordinates of the first point.</td></tr><tr><td style="text-align:left;"><code>p2</code></td><td style="text-align:left;"><code>tuple[int]</code></td><td style="text-align:left;">The (x,y) integer coordinates of the second point.</td></tr><tr><td style="text-align:left;"><code>line</code></td><td style="text-align:left;"><code>int</code></td><td style="text-align:left;">An integer representing the equation of a line, that is paralell to one of the axes.</td></tr><tr><td style="text-align:left;"><code>vertical</code></td><td style="text-align:left;"><code>bool</code></td><td style="text-align:left;">A boolean flag indicating if the comparison line is a vertical line (paralell to the y-axis).</td></tr></tbody></table><h3 id="error-handling" tabindex="-1">Error Handling <a class="header-anchor" href="#error-handling" aria-label="Permalink to &quot;Error Handling&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">Raises</th><th style="text-align:left;">Encountered Error</th></tr></thead><tbody><tr><td style="text-align:left;"><code>ValueError</code></td><td style="text-align:left;">Given unrecognized input parameter values.</td></tr><tr><td style="text-align:left;"><code>TypeError</code></td><td style="text-align:left;">Given invalid input parameter typings.</td></tr></tbody></table><h2 id="transcoding-input-video-files" tabindex="-1">Transcoding Input Video Files <a class="header-anchor" href="#transcoding-input-video-files" aria-label="Permalink to &quot;Transcoding Input Video Files&quot;">​</a></h2><p>PyFAME can operate over video files in the .mp4 and .mov formats, for any input video files encoded in another container, <code>transcode_video_to_mp4()</code> is your solution. This function leverages <code>cv2.VideoCapture()</code> to decode input video files, and <code>cv2.VideoWriter()</code> with fourcc encoding <code>*&#39;mp4v&#39;</code> to encode the videos to mp4. <code>transcode_video_to_mp4()</code> can transcode entire nested directories of videos in a single call, by providing the top-level directory path to <code>input_dir</code> and specifying <code>with_sub_dirs=True</code>.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> transcode_video_to_mp4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(input_dir:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, output_dir:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">str</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, with_sub_dirs:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bool</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> False</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -&gt; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span></code></pre></div><table tabindex="0"><thead><tr><th style="text-align:left;">Parameter</th><th style="text-align:left;">Type</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;"><code>input_dir</code></td><td style="text-align:left;"><code>str</code></td><td style="text-align:left;">A path string to the directory containing files to process.</td></tr><tr><td style="text-align:left;"><code>output_dir</code></td><td style="text-align:left;"><code>str</code></td><td style="text-align:left;">A path string to the directory where processed files will be output.</td></tr><tr><td style="text-align:left;"><code>with_sub_dirs</code></td><td style="text-align:left;"><code>bool</code></td><td style="text-align:left;">A boolean flag indicating if the input directory contains nested subdirectories.</td></tr></tbody></table><h3 id="error-handling-1" tabindex="-1">Error Handling <a class="header-anchor" href="#error-handling-1" aria-label="Permalink to &quot;Error Handling&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">Raises</th><th style="text-align:left;">Encountered Error</th></tr></thead><tbody><tr><td style="text-align:left;"><code>ValueError</code></td><td style="text-align:left;">Given unrecognized input parameter values.</td></tr><tr><td style="text-align:left;"><code>TypeError</code></td><td style="text-align:left;">Given invalid input parameter typings.</td></tr><tr><td style="text-align:left;"><code>OSError</code></td><td style="text-align:left;">Given invalid path-strings to the input or output directory.</td></tr></tbody></table><h2 id="creating-custom-landmark-paths" tabindex="-1">Creating Custom Landmark Paths <a class="header-anchor" href="#creating-custom-landmark-paths" aria-label="Permalink to &quot;Creating Custom Landmark Paths&quot;">​</a></h2><p>Almost all of the facial manipulation functions take in an input paramater list of landmark paths. PyFAME contains many predefined landmark paths, but in the case a user may want to create their own custom path, they can use the <code>create_path()</code> function. This function takes in a list of integer landmark indicies (0-477) that align with MediaPipe&#39;s FaceMesh landmarks, and returns a list of tuples creating a closed path with the indicies provided. For example, if [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] was passed in, [(&#39;a&#39;, &#39;b&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;c&#39;, &#39;a&#39;)] would be returned.</p><div class="language-Python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">Python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> create_path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(landmark_set:list[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) -&gt; list[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tuple</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]:</span></span></code></pre></div><table tabindex="0"><thead><tr><th style="text-align:left;">Parameter</th><th style="text-align:left;">Type</th><th style="text-align:left;">Description</th></tr></thead><tbody><tr><td style="text-align:left;"><code>landmark_set</code></td><td style="text-align:left;"><code>list[int]</code></td><td style="text-align:left;">A list of integer landmark id&#39;s that align with the MediaPipe FaceMesh landmarks. These landmark id&#39;s are integers in the range [0, 477].</td></tr></tbody></table>',25)]))}const k=e(l,[["render",n]]);export{g as __pageData,k as default};
